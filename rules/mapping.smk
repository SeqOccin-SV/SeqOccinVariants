#!/usr/bin/env python


## rule to produce a fofn file for pbmm2
rule write_fofn:
	input:
		config['samples']
	output:
		"fofn/{sample}-{tech}.fofn"
	log:
		"logs/fofn/{sample}-{tech}.out",
		"logs/fofn/{sample}-{tech}.log"
	params:
		files = get_files
	shell:
		"for f in {params.files}; do echo $f >> {output}; done"


# rule to align reads with minimap2 wrapper from fastq file
# generally, fastq file input is used for HiFi reads coming out of CCS
rule pbmm2:
	input:
		fofn = "fofn/{sample}-{tech}.fofn",
		ref = config['ref']
	output:
		temp("mapping/{sample}-{tech}-pbmm2-unsorted.bam")
	log:
		stdout="logs/pbmm2/{sample}-{tech}.out",
		stderr="logs/pbmm2/{sample}-{tech}.log"
	benchmark:
		"bench/{sample}-{tech}.pbmm2.benchmark.txt"
	resources:
		type = lambda wildcards, input: get_fofn_types(input.fofn)
	params:
		is_ccs = lambda wildcards, resources: '--preset CCS' if resources.type==2 or resources.type==3 else '',
		need_rg = lambda wildcards,resources: '--sample '+wildcards.sample+' --rg @RG\\tID:movie'+wildcards.sample+'\\tSM:'+wildcards.sample if resources.type==3 else ''
	conda:
		'../envs/pbsv_env.yaml'
	threads: get_threads('pbmm2',20)
	shell:
		"""
		pbmm2 align {input.ref} {input.fofn} {output} \
		-j {threads} \
		{params.is_ccs} \
		{params.need_rg} 2> {log.stderr} > {log.stdout}
		"""


# Indexing for minimap
rule genomeindex:
	input:
		config['ref']
	output:
		"minimapindex/genome.mmi"
	conda:
		'../envs/svim_env.yaml'
	shell:
		"minimap2 -x map-ont -d {output} {input}"


rule minimap:
	input:
		reads=get_files,
		minimapindex="minimapindex/genome.mmi"
	output:
		temp("mapping/{sample}-{tech}-minimap-unsorted.bam")
	threads:
		get_threads("minimap", 12)
	log:
		stdout="logs/minimap/{sample}-{tech}-minimap.out",
		stderr="logs/minimap/{sample}-{tech}-minimap.log"
	conda:
		'../envs/svim_env.yaml'
	params:
		ulim = config['ulimit']
	shell:
		"minimap2 --MD -t {threads} -a {input.minimapindex} {input.reads} -o {output} 2> {log.stderr} > {log.stdout}"


# Rule to sort bam file from pbmm2
# This is done in a separate rule instead of using pbmm2 --sort
# for memory usage optimisation
rule bam_sort:
	input:
		"mapping/{sample}-{tech}-{mapping}-unsorted.bam"
	output:
		"mapping/{sample}-{tech}-{mapping}.bam"
	log:
		"logs/samtools/{sample}-{tech}-{mapping}-sort.log"
	conda:
		'../envs/samtools_env.yaml'
	threads: get_threads('bam_sort', 4)
	params:
		mem = get_mem_per_CPU('bam_sort', 4, 4),
		ulim = config['ulimit']
	shell:
		"ulimit -n {params.ulim}; "
		"export TMPDIR=./ ;"
		"""
		samtools sort -T {wildcards.sample} \
		-@ {threads} \
		-m {params.mem}M \
		-o {output} {input} 2> {log}
		"""


### BAM ADDONS


# the output of samtools index seems to also be generated by samtools stats executed in rule bam_stats.
rule bam_index:
	input:
		"mapping/{sample}-{tech}-{mapping}.bam"
	output:
		"mapping/{sample}-{tech}-{mapping}.bam.bai"
	log:
		"logs/samtools/{sample}-{tech}-{mapping}-index.log"
	conda:
		'../envs/samtools_env.yaml'
	threads: get_threads('bam_index',4)
	shell:
		"samtools index -@ {threads} {input} 2> {log}"


rule bam_stats:
	input:
		get_bam
	output:
		"mapping/{sample}-{tech}-{mapping}.bam.stats"
	log:
		"logs/samtools/{sample}-{tech}-{mapping}-stats.log"
	conda:
		'../envs/samtools_env.yaml'
	threads: get_threads('bam_stats',4)
	shell:
		"samtools stats -@ {threads} {input} > {output} 2> {log}"
